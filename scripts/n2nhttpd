#!/usr/bin/env python3
# Licensed under GPLv3
#
# Simple http server to allow user control of n2n edge nodes
#
# Currently only for demonstration
# - needs nicer looking html written
# - needs more json interfaces in edge
#
# Try it out with
#   http://localhost:8080/
#   http://localhost:8080/edge/peer
#   http://localhost:8080/edge/super

import argparse
import socket
import json
import socketserver
import http.server

from http import HTTPStatus

next_tag = 0


def send_cmd(port, debug, cmd):
    """Send a text command to the edge and process the JSON reply packets"""
    global next_tag

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    tagstr = str(next_tag)
    next_tag = (next_tag + 1) % 1000

    message = "{} {}".format(cmd, tagstr).encode('utf8')
    sock.sendto(message, ("127.0.0.1", 5644))

    # FIXME:
    # - there is no timeout for any of the socket handling

    begin, _ = sock.recvfrom(1024)
    begin = json.loads(begin.decode('utf8'))
    assert(begin['_tag'] == tagstr)
    assert(begin['_type'] == 'begin')
    assert(begin['_cmd'] == cmd)

    result = list()

    while True:
        data, _ = sock.recvfrom(1024)
        data = json.loads(data.decode('utf8'))
        assert(data['_tag'] == tagstr)

        if data['_type'] == 'unknowncmd':
            raise ValueError('Unknown command {}'.format(cmd))

        if data['_type'] == 'end':
            return result

        if data['_type'] != 'row':
            raise ValueError('Unknown data type {} from '
                             'edge'.format(data['_type']))

        # remove our boring metadata
        del data['_tag']
        del data['_type']

        if debug:
            print(data)

        result.append(data)


indexhtml = """
<html>
<head>
 <title>n2n management</title>
</head>
<body>
 <div id="time"></div>
 <br>
 Supernodes:
 <div id="super"></div>
 <br>
 Peers:
 <div id="peer"></div>

 <script>
  function rows2table(id, columns, data) {
    let s = "<table border=1 cellspacing=0>"
    s += "<tr>"
    columns.forEach((col) => {
        s += "<th>" + col
    });
    data.forEach((row) => {
        s += "<tr>"
        columns.forEach((col) => {
            s += "<td>" + row[col]
        });
    });

    s += "</table>"
    let div = document.getElementById(id);
    div.innerHTML=s
  }

  function fetch_table(url, id, columns) {
    fetch(url)
      .then(function (response) {
        return response.json();
      })
      .then(function (data) {
        rows2table(id,columns,data);
      })
      .catch(function (err) {
        console.log('error: ' + err);
      });
  }

  function refresh_job() {
    let now = new Date().getTime();

    let time = document.getElementById('time');
    time.innerHTML="last updated: " + now;

    fetch_table(
        'edge/super',
        'super',
        ['version','current','macaddr','sockaddr','uptime']
    );
    fetch_table(
        'edge/peer',
        'peer',
        ['mode','ip4addr','macaddr','sockaddr','desc']
    );
  }

  function refresh_setup(interval) {
    var timer = setInterval(refresh_job, interval);
  }

refresh_setup(5000);
refresh_job();
 </script>
</body>
</html>
"""


class SimpleHandler(http.server.BaseHTTPRequestHandler):

    def log_request(self, code='-', size='-'):
        # Dont spam the output
        pass

    def do_GET(self):
        url_tail = self.path

        if url_tail == "/":
            self.send_response(HTTPStatus.OK)
            self.send_header('Content-type', 'text/html; charset=utf-8')
            self.end_headers()
            self.wfile.write(indexhtml.encode('utf8'))
            return

        if url_tail.startswith("/edge/"):
            tail = url_tail.split('/')
            cmd = 'j.' + tail[2]
            # if commands ever need args, use more of the path components

            try:
                data = send_cmd(5644, False, cmd)
            except ValueError:
                self.send_response(HTTPStatus.BAD_REQUEST)
                self.end_headers()
                self.wfile.write(b'Bad Command')
                return

            self.send_response(HTTPStatus.OK)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps(data).encode('utf8'))
            return

        self.send_response(HTTPStatus.NOT_FOUND)
        self.end_headers()
        self.wfile.write(b'Not Found')
        return


def main():
    ap = argparse.ArgumentParser(
            description='Control the running local n2n edge via http')
    #  TODO - this needs to pass into the handler object
    # ap.add_argument('-t', '--mgmtport', action='store', default=5644,
    #                 help='Management Port (default=5644)')
    # ap.add_argument('-d', '--debug', action='store_true',
    #                 help='Also show raw internal data')
    ap.add_argument('port', action='store',
                    default=8080, type=int, nargs='?',
                    help='Serve requests on TCP port (default 8080)')

    args = ap.parse_args()

    with socketserver.TCPServer(("", args.port), SimpleHandler) as httpd:
        httpd.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        httpd.serve_forever()


if __name__ == '__main__':
    main()
