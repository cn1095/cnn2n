#!/usr/bin/env python3
# Licensed under GPLv3
#
# Simple script to query the management interface of a running n2n edge node

import argparse
import socket
import json
import collections

next_tag = 0


def send_cmd(port, debug, key, cmd):
    """Send a text command to the edge and process the JSON reply packets"""
    global next_tag

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    tagstr = str(next_tag)
    next_tag = (next_tag + 1) % 1000

    if key is not None:
        options = tagstr + ':1:' + key
    else:
        options = tagstr

    msgtype = "r"

    message = "{} {} {}".format(msgtype, options, cmd).encode('utf8')
    sock.sendto(message, ("127.0.0.1", 5644))

    # FIXME:
    # - there is no timeout for any of the socket handling

    data, _ = sock.recvfrom(1024)
    data = json.loads(data.decode('utf8'))
    assert(data['_tag'] == tagstr)

    if data['_type'] == 'error':
        raise ValueError('Error: {}'.format(data['error']))

    assert(data['_type'] == 'begin')
    assert(data['cmd'] == cmd)

    result = list()

    while True:
        data, _ = sock.recvfrom(1024)
        data = json.loads(data.decode('utf8'))
        assert(data['_tag'] == tagstr)

        if data['_type'] == 'error':
            raise ValueError('Error with command {}'.format(cmd))

        if data['_type'] == 'end':
            return result

        if data['_type'] != 'row':
            raise ValueError('Unknown data type {} from '
                             'edge'.format(data['_type']))

        # remove our boring metadata
        del data['_tag']
        del data['_type']

        if debug:
            print(data)

        result.append(data)


def str_table(rows, columns):
    """Given an array of dicts, do a simple table print"""
    result = list()
    widths = collections.defaultdict(lambda: 0)
    for row in rows:
        for col in columns:
            if col in row:
                widths[col] = max(widths[col], len(str(row[col])))

    for col in columns:
        if widths[col] == 0:
            widths[col] = 1
        result += "{:{}.{}} ".format(col, widths[col], widths[col])
    result += "\n"

    for row in rows:
        for col in columns:
            if col in row:
                data = row[col]
            else:
                data = ''
            result += "{:{}} ".format(data, widths[col])
        result += "\n"

    return ''.join(result)


def subcmd_show_supernodes(args):
    rows = send_cmd(args.port, args.debug, args.key, 'super')
    columns = [
        'version',
        'current',
        'macaddr',
        'sockaddr',
        'uptime',
    ]

    return str_table(rows, columns)


def subcmd_show_peers(args):
    rows = send_cmd(args.port, args.debug, args.key, 'peer')
    columns = [
        'mode',
        'ip4addr',
        'macaddr',
        'sockaddr',
        'desc',
    ]

    return str_table(rows, columns)


def subcmd_show_help(args):
    result = 'Commands with pretty-printed output:\n\n'
    for name, cmd in subcmds.items():
        result += "{:12} {}\n".format(name, cmd['help'])

    result += "\n"
    result += "Possble remote commands:\n"
    result += "(those without pretty-printer, will pass-through)\n\n"
    rows = send_cmd(args.port, args.debug, args.key, args.cmd)
    result += json.dumps(rows, sort_keys=True, indent=4)
    return result


subcmds = {
    'help': {
        'func': subcmd_show_help,
        'help': 'Show available commands',
    },
    'supernodes': {
        'func': subcmd_show_supernodes,
        'help': 'Show the list of supernodes',
    },
    'peers': {
        'func': subcmd_show_peers,
        'help': 'Show the list of peers',
    },
}


def subcmd_default(args):
    """Just pass command through to edge"""
    rows = send_cmd(args.port, args.debug, args.key, args.cmd)
    return json.dumps(rows, sort_keys=True, indent=4)


def main():
    ap = argparse.ArgumentParser(
            description='Query the running local n2n edge')
    ap.add_argument('-t', '--port', action='store', default=5644,
                    help='Management Port (default=5644)')
    ap.add_argument('-k', '--key', action='store',
                    help='Password for mgmt commands')
    ap.add_argument('-d', '--debug', action='store_true',
                    help='Also show raw internal data')
    ap.add_argument('--read', action='store_true',
                    help='Make a read request (default)')
    ap.add_argument('--write', action='store_false', dest='read',
                    help='Make a write request')
    ap.add_argument('cmd', action='store',
                    help='Command to run (try "help" for list)')

    args = ap.parse_args()

    if args.cmd not in subcmds:
        func = subcmd_default
    else:
        func = subcmds[args.cmd]['func']

    result = func(args)
    print(result)


if __name__ == '__main__':
    main()
